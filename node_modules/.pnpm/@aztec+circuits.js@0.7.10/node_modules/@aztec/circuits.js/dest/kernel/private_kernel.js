import { BufferReader } from '@aztec/foundation/serialize';
import { Buffer } from 'buffer';
import { FUNCTION_TREE_HEIGHT, Fr } from '../index.js';
import { serializeBufferArrayToVector } from '../utils/serialize.js';
export { privateKernelSimOrdering, privateKernelSimInit, privateKernelSimInner } from '../cbind/circuits.gen.js';
/**
 * Computes contract's function tree from the given leaves.
 * @param wasm - The circuits wasm instance.
 * @param leaves - The leaves of the function tree.
 * @returns All of a function tree's nodes.
 */
export function computeFunctionTree(wasm, leaves) {
    // Init pedersen if needed
    wasm.call('pedersen__init');
    // Size of the tree is 2^height times size of each element,
    // plus 4 for the size used in the std::vector serialization
    const outputBufSize = 2 ** (FUNCTION_TREE_HEIGHT + 1) * Fr.SIZE_IN_BYTES + 4;
    // Allocate memory for the input and output buffers, and populate input buffer
    const inputVector = serializeBufferArrayToVector(leaves.map(fr => fr.toBuffer()));
    const inputBufPtr = wasm.call('bbmalloc', inputVector.length);
    const outputBufPtr = wasm.call('bbmalloc', outputBufSize * 100);
    wasm.writeMemory(inputBufPtr, inputVector);
    // Run and read outputs
    wasm.call('abis__compute_function_tree', inputBufPtr, outputBufPtr);
    const outputBuf = Buffer.from(wasm.getMemorySlice(outputBufPtr, outputBufPtr + outputBufSize));
    const reader = new BufferReader(outputBuf);
    const output = reader.readVector(Fr);
    // Free memory
    wasm.call('bbfree', outputBufPtr);
    wasm.call('bbfree', inputBufPtr);
    return output;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpdmF0ZV9rZXJuZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMva2VybmVsL3ByaXZhdGVfa2VybmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUUzRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRWhDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxFQUFFLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDdkQsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHckUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLG9CQUFvQixFQUFFLHFCQUFxQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFakg7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsSUFBa0IsRUFBRSxNQUFZO0lBQ2xFLDBCQUEwQjtJQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFNUIsMkRBQTJEO0lBQzNELDREQUE0RDtJQUM1RCxNQUFNLGFBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUU3RSw4RUFBOEU7SUFDOUUsTUFBTSxXQUFXLEdBQUcsNEJBQTRCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEYsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGFBQWEsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNoRSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUUzQyx1QkFBdUI7SUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsRUFBRSxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDcEUsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxZQUFZLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUMvRixNQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzQyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRXJDLGNBQWM7SUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUVqQyxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIn0=