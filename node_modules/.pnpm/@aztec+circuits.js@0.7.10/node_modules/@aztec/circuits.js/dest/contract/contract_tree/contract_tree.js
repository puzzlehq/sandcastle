import { Fr, FunctionLeafPreimage } from '@aztec/circuits.js';
import { computeFunctionLeaf, hashVK } from '@aztec/circuits.js/abis';
import { FunctionSelector, FunctionType } from '@aztec/foundation/abi';
/**
 * Computes the hash of a hex-encoded string representation of a verification key (vk).
 * The input 'vk' should be a hexadecimal string, and the resulting hash is computed using 'hashVK' function.
 * Returns a Promise that resolves to a Buffer containing the hash of the verification key.
 *
 * @param vk - The hex-encoded string representing the verification key.
 * @param wasm - An instance of CircuitsWasm class used for hashing.
 * @returns A Promise resolving to a Buffer containing the hash of the verification key.
 */
export function hashVKStr(vk, wasm) {
    // TODO - check consistent encoding
    return hashVK(wasm, Buffer.from(vk, 'hex'));
}
/**
 * Determine if the given function is a constructor.
 * This utility function checks if the 'name' property of the input object is "constructor".
 * Returns true if the function is a constructor, false otherwise.
 *
 * @param Object - An object containing a 'name' property.
 * @returns Boolean indicating if the function is a constructor.
 */
export function isConstructor({ name, }) {
    return name === 'constructor';
}
/**
 * @param Object - An object containing function name and type.
 * @returns Boolean indicating if the function is constrained and therefore in the function tree.
 */
export function isConstrained({ name, functionType, }) {
    return functionType !== FunctionType.UNCONSTRAINED && !isConstructor({ name });
}
/**
 * Generate function leaves for the constrained functions in a contract.
 * Only computes leaves for functions that are either secret or open and not constructors.
 * Each function leaf is computed from its selector, privacy flag, hashed verification key, and hashed bytecode.
 *
 * @param functions - Array of ContractFunctionDao objects representing the functions in a contract.
 * @param wasm - CircuitsWasm instance used for hashing and computations.
 * @returns An array of Fr instances representing the generated function leaves.
 */
export function generateFunctionLeaves(functions, wasm) {
    const targetFunctions = functions.filter(isConstrained);
    const result = [];
    for (let i = 0; i < targetFunctions.length; i++) {
        const f = targetFunctions[i];
        const selector = FunctionSelector.fromNameAndParameters(f.name, f.parameters);
        const isInternal = f.isInternal;
        const isPrivate = f.functionType === FunctionType.SECRET;
        // All non-unconstrained functions have vks
        const vkHash = hashVKStr(f.verificationKey, wasm);
        // TODO
        // FIXME: https://github.com/AztecProtocol/aztec3-packages/issues/262
        // const acirHash = keccak(Buffer.from(f.bytecode, 'hex'));
        const acirHash = Buffer.alloc(32, 0);
        const fnLeafPreimage = new FunctionLeafPreimage(selector, isInternal, isPrivate, Fr.fromBuffer(vkHash), Fr.fromBuffer(acirHash));
        const fnLeaf = computeFunctionLeaf(wasm, fnLeafPreimage);
        result.push(fnLeaf);
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cmFjdC9jb250cmFjdF90cmVlL2NvbnRyYWN0X3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFxQyxFQUFFLEVBQWdCLG9CQUFvQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDL0csT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUV2RTs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQUMsRUFBVSxFQUFFLElBQWtCO0lBQ3RELG1DQUFtQztJQUNuQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsRUFDNUIsSUFBSSxHQU1MO0lBQ0MsT0FBTyxJQUFJLEtBQUssYUFBYSxDQUFDO0FBQ2hDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUFDLEVBQzVCLElBQUksRUFDSixZQUFZLEdBVWI7SUFDQyxPQUFPLFlBQVksS0FBSyxZQUFZLENBQUMsYUFBYSxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNqRixDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsU0FBZ0MsRUFBRSxJQUFrQjtJQUN6RixNQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3hELE1BQU0sTUFBTSxHQUFTLEVBQUUsQ0FBQztJQUN4QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMvQyxNQUFNLENBQUMsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsTUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDOUUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUNoQyxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUMsWUFBWSxLQUFLLFlBQVksQ0FBQyxNQUFNLENBQUM7UUFDekQsMkNBQTJDO1FBQzNDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsZUFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNuRCxPQUFPO1FBQ1AscUVBQXFFO1FBQ3JFLDJEQUEyRDtRQUMzRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVyQyxNQUFNLGNBQWMsR0FBRyxJQUFJLG9CQUFvQixDQUM3QyxRQUFRLEVBQ1IsVUFBVSxFQUNWLFNBQVMsRUFDVCxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUNyQixFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUN4QixDQUFDO1FBQ0YsTUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDckI7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIn0=