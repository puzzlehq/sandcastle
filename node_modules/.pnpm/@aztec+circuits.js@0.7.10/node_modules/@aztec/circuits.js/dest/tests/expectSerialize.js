import { uint8ArrayToNum } from '../utils/serialize.js';
import { CircuitsWasm } from '../wasm/circuits_wasm.js';
/**
 * Simplify e.g. 0x0003 into 0x3.
 * @param input - The input string, with hex somewhere inside.
 * @returns The output string with fixed hex.
 */
export function simplifyHexValues(input) {
    const regex = /0x[\dA-Fa-f]+/g;
    const matches = input.match(regex) || [];
    const simplifiedMatches = matches.map(match => '0x' + BigInt(match).toString(16));
    const result = input.replace(regex, () => simplifiedMatches.shift() || '');
    return result;
}
/**
 * Test utility. Sends a serialized buffer to wasm and gets the result.
 * @param inputBuf - Buffer to write.
 * @param serializeMethod - Method to use buffer with.
 * @param wasm - Optional circuit wasm. If not set, we fetch a singleton.
 */
async function callWasm(inputBuf, serializeMethod, wasm) {
    wasm = wasm || (await CircuitsWasm.get());
    const inputBufPtr = wasm.call('bbmalloc', inputBuf.length);
    wasm.writeMemory(inputBufPtr, inputBuf);
    const outputBufSizePtr = wasm.call('bbmalloc', 4);
    // Get a string version of our object. As a quick and dirty test,
    // we compare a snapshot of its string form to its previous form.
    const outputBufPtr = wasm.call(serializeMethod, inputBufPtr, outputBufSizePtr);
    // Read the size pointer
    const outputBufSize = uint8ArrayToNum(wasm.getMemorySlice(outputBufSizePtr, outputBufSizePtr + 4));
    // Copy into our own buffer
    const outputBuf = Buffer.from(wasm.getMemorySlice(outputBufPtr, outputBufPtr + outputBufSize));
    // Free memory
    wasm.call('bbfree', outputBufPtr);
    wasm.call('bbfree', outputBufSizePtr);
    wasm.call('bbfree', inputBufPtr);
    return outputBuf;
}
/**
 * Test utility. Checks a buffer serialize against a snapshot.
 * @param inputBuf - Buffer to write to.
 * @param serializeMethod - Method to use buffer with.
 * @param wasm - Optional circuit wasm. If not set, we fetch a singleton.
 */
export async function expectSerializeToMatchSnapshot(inputBuf, serializeMethod, wasm) {
    const outputBuf = await callWasm(inputBuf, serializeMethod, wasm);
    const outputStr = simplifyHexValues(Buffer.from(outputBuf).toString('utf-8'));
    expect(outputStr).toMatchSnapshot();
}
/**
 * Test utility. Serializes an object, passes it to a wasm reserialize method,
 * gets it back, deserializes it, and checks it matches the original.
 * @param inputObj - Object to check.
 * @param serializeMethod - Wasm method to send and get back the object.
 * @param deserialize - Method to deserialize the object with.
 * @param wasm - Optional circuit wasm. If not set, we fetch a singleton.
 */
export async function expectReserializeToMatchObject(inputObj, serializeMethod, deserialize, wasm) {
    const outputBuf = await callWasm(inputObj.toBuffer(), serializeMethod, wasm);
    const deserializedObj = deserialize(outputBuf);
    expect(deserializedObj).toEqual(deserializedObj);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwZWN0U2VyaWFsaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Rlc3RzL2V4cGVjdFNlcmlhbGl6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsS0FBYTtJQUM3QyxNQUFNLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQztJQUMvQixNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QyxNQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2xGLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzNFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILEtBQUssVUFBVSxRQUFRLENBQUMsUUFBZ0IsRUFBRSxlQUF1QixFQUFFLElBQW1CO0lBQ3BGLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN4QyxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRWxELGlFQUFpRTtJQUNqRSxpRUFBaUU7SUFDakUsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFFL0Usd0JBQXdCO0lBQ3hCLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFbkcsMkJBQTJCO0lBQzNCLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFFL0YsY0FBYztJQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFakMsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSw4QkFBOEIsQ0FBQyxRQUFnQixFQUFFLGVBQXVCLEVBQUUsSUFBbUI7SUFDakgsTUFBTSxTQUFTLEdBQUcsTUFBTSxRQUFRLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRSxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzlFLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztBQUN0QyxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsOEJBQThCLENBT2xELFFBQVcsRUFBRSxlQUF1QixFQUFFLFdBQStCLEVBQUUsSUFBbUI7SUFDMUYsTUFBTSxTQUFTLEdBQUcsTUFBTSxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3RSxNQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDL0MsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUNuRCxDQUFDIn0=