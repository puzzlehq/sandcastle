import { padArrayEnd } from '@aztec/foundation/collection';
import { Buffer } from 'buffer';
import chunk from 'lodash.chunk';
import { abisComputeBlockHash, abisComputeBlockHashWithGlobals, abisComputeCommitmentNonce, abisComputeGlobalsHash, abisComputePublicDataTreeIndex, abisComputePublicDataTreeValue, abisComputeUniqueCommitment, abisSiloCommitment, abisSiloNullifier, } from '../cbind/circuits.gen.js';
import { AztecAddress, FUNCTION_SELECTOR_NUM_BYTES, Fr, PrivateCallStackItem, PublicCallStackItem, Vector, } from '../index.js';
import { serializeBufferArrayToVector } from '../utils/serialize.js';
/**
 * Synchronously calls a wasm function.
 * @param wasm - The wasm wrapper.
 * @param fnName - The name of the function to call.
 * @param input - The input buffer or object serializable to a buffer.
 * @param expectedOutputLength - The expected length of the output buffer.
 * @returns The output buffer.
 */
export function wasmSyncCall(wasm, fnName, input, expectedOutputLength) {
    const inputData = input instanceof Buffer ? input : input.toBuffer();
    const outputBuf = wasm.call('bbmalloc', expectedOutputLength);
    const inputBuf = wasm.call('bbmalloc', inputData.length);
    wasm.writeMemory(inputBuf, inputData);
    wasm.call(fnName, inputBuf, outputBuf);
    const buf = Buffer.from(wasm.getMemorySlice(outputBuf, outputBuf + expectedOutputLength));
    wasm.call('bbfree', outputBuf);
    wasm.call('bbfree', inputBuf);
    return buf;
}
/**
 * Writes input buffers to wasm memory, calls a wasm function, and returns the output buffer.
 * @param wasm - A module providing low-level wasm access.
 * @param fnName - The name of the function to call.
 * @param inputBuffers - Buffers to write to wasm memory.
 * @param expectedOutputLength - The expected length of the output buffer.
 * @returns The output buffer.
 */
export function inputBuffersToOutputBuffer(wasm, fnName, inputBuffers, expectedOutputLength) {
    const offsets = [];
    const totalLength = inputBuffers.reduce((total, cur) => {
        offsets.push(total);
        return total + cur.length;
    }, 0);
    const outputBuf = wasm.call('bbmalloc', expectedOutputLength);
    const inputBuf = wasm.call('bbmalloc', totalLength);
    wasm.writeMemory(inputBuf, Buffer.concat(inputBuffers));
    const args = offsets.map(offset => inputBuf + offset);
    wasm.call(fnName, ...args, outputBuf);
    const output = Buffer.from(wasm.getMemorySlice(outputBuf, outputBuf + expectedOutputLength));
    wasm.call('bbfree', inputBuf);
    wasm.call('bbfree', outputBuf);
    return output;
}
/**
 * Computes a hash of a transaction request.
 * @param wasm - A module providing low-level wasm access.
 * @param txRequest - The transaction request.
 * @returns The hash of the transaction request.
 */
export function hashTxRequest(wasm, txRequest) {
    wasm.call('pedersen__init');
    return wasmSyncCall(wasm, 'abis__hash_tx_request', txRequest, 32);
}
/**
 * Computes a function selector from a given function signature.
 * @param wasm - A module providing low-level wasm access.
 * @param funcSig - The function signature.
 * @returns The function selector.
 */
export function computeFunctionSelector(wasm, funcSig) {
    return wasmSyncCall(wasm, 'abis__compute_function_selector', 
    // Important - explicit C-string compatibility with a null terminator!
    // In the future we want to move away from this fiddly C-string processing.
    Buffer.from(funcSig + '\0'), FUNCTION_SELECTOR_NUM_BYTES);
}
/**
 * Computes a hash of a given verification key.
 * @param wasm - A module providing low-level wasm access.
 * @param vkBuf - The verification key.
 * @returns The hash of the verification key.
 */
export function hashVK(wasm, vkBuf) {
    wasm.call('pedersen__init');
    return wasmSyncCall(wasm, 'abis__hash_vk', vkBuf, 32);
}
/**
 * Computes a function leaf from a given preimage.
 * @param wasm - A module providing low-level wasm access.
 * @param fnLeaf - The function leaf preimage.
 * @returns The function leaf.
 */
export function computeFunctionLeaf(wasm, fnLeaf) {
    wasm.call('pedersen__init');
    return Fr.fromBuffer(wasmSyncCall(wasm, 'abis__compute_function_leaf', fnLeaf, 32));
}
/**
 * Computes a function tree root from function leaves.
 * @param wasm - A module providing low-level wasm access.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns The function tree root.
 */
export function computeFunctionTreeRoot(wasm, fnLeaves) {
    const inputVector = serializeBufferArrayToVector(fnLeaves.map(fr => fr.toBuffer()));
    wasm.call('pedersen__init');
    const result = wasmSyncCall(wasm, 'abis__compute_function_tree_root', inputVector, 32);
    return Fr.fromBuffer(result);
}
/**
 * Computes a constructor hash.
 * @param wasm - A module providing low-level wasm access.
 * @param functionData - Constructor's function data.
 * @param argsHash - Constructor's arguments hashed.
 * @param constructorVKHash - Hash of the constructor's verification key.
 * @returns The constructor hash.
 */
export function hashConstructor(wasm, functionData, argsHash, constructorVKHash) {
    wasm.call('pedersen__init');
    const result = inputBuffersToOutputBuffer(wasm, 'abis__hash_constructor', [functionData.toBuffer(), argsHash.toBuffer(), constructorVKHash], 32);
    return Fr.fromBuffer(result);
}
/**
 * Computes a contract address.
 * @param wasm - A module providing low-level wasm access.
 * @param deployerPubKey - The pubkey of the contract deployer.
 * @param contractAddrSalt - The salt used as one of the inputs of the contract address computation.
 * @param fnTreeRoot - The function tree root of the contract being deployed.
 * @param constructorHash - The hash of the constructor.
 * @returns The contract address.
 */
export function computeContractAddress(wasm, deployerPubKey, contractAddrSalt, fnTreeRoot, constructorHash) {
    wasm.call('pedersen__init');
    const result = inputBuffersToOutputBuffer(wasm, 'abis__compute_contract_address', [deployerPubKey.toBuffer(), contractAddrSalt.toBuffer(), fnTreeRoot.toBuffer(), constructorHash.toBuffer()], 32);
    return new AztecAddress(result);
}
/**
 * Computes a partial address. Consists of all contract address components except the deployer public key.
 * @param wasm - A module providing low-level wasm access.
 * @param contractAddrSalt - The salt used as one of the inputs of the contract address computation.
 * @param fnTreeRoot - The function tree root of the contract being deployed.
 * @param constructorHash - The hash of the constructor.
 * @returns The partially constructed contract address.
 */
export function computePartialAddress(wasm, contractAddrSalt, fnTreeRoot, constructorHash) {
    wasm.call('pedersen__init');
    const result = inputBuffersToOutputBuffer(wasm, 'abis__compute_partial_address', [contractAddrSalt.toBuffer(), fnTreeRoot.toBuffer(), constructorHash.toBuffer()], 32);
    return Fr.fromBuffer(result);
}
/**
 * Computes a contract address from its partial address and the pubkey.
 * @param wasm - A module providing low-level wasm access.
 * @param partial - The salt used as one of the inputs of the contract address computation.
 * @param fnTreeRoot - The function tree root of the contract being deployed.
 * @param constructorHash - The hash of the constructor.
 * @returns The partially constructed contract address.
 */
export function computeContractAddressFromPartial(wasm, pubKey, partialAddress) {
    wasm.call('pedersen__init');
    const result = inputBuffersToOutputBuffer(wasm, 'abis__compute_contract_address_from_partial', [pubKey.toBuffer(), partialAddress.toBuffer()], 32);
    return new AztecAddress(result);
}
/**
 * Computes a commitment nonce, which will be used to create a unique commitment.
 * @param wasm - A module providing low-level wasm access.
 * @param nullifierZero - The first nullifier in the tx.
 * @param commitmentIndex - The index of the commitment.
 * @returns A commitment nonce.
 */
export function computeCommitmentNonce(wasm, nullifierZero, commitmentIndex) {
    wasm.call('pedersen__init');
    return abisComputeCommitmentNonce(wasm, nullifierZero, new Fr(commitmentIndex));
}
/**
 * Computes a siloed commitment, given the contract address and the commitment itself.
 * A siloed commitment effectively namespaces a commitment to a specific contract.
 * @param wasm - A module providing low-level wasm access.
 * @param contract - The contract address
 * @param innerCommitment - The commitment to silo.
 * @returns A siloed commitment.
 */
export function siloCommitment(wasm, contract, innerCommitment) {
    wasm.call('pedersen__init');
    return abisSiloCommitment(wasm, contract, innerCommitment);
}
/**
 * Computes a unique commitment. It includes a nonce which contains data that guarantees the commiment will be unique.
 * @param wasm - A module providing low-level wasm access.
 * @param nonce - The contract address.
 * @param siloedCommitment - An siloed commitment.
 * @returns A unique commitment.
 */
export function computeUniqueCommitment(wasm, nonce, siloedCommitment) {
    wasm.call('pedersen__init');
    return abisComputeUniqueCommitment(wasm, nonce, siloedCommitment);
}
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param wasm - A module providing low-level wasm access.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export function siloNullifier(wasm, contract, innerNullifier) {
    wasm.call('pedersen__init');
    return abisSiloNullifier(wasm, contract, innerNullifier);
}
/**
 * Computes the block hash given the blocks globals and roots.
 * @param wasm - A module providing low-level wasm access.
 * @param globals - The global variables to put into the block hash.
 * @param privateDataTree - The root of the private data tree.
 * @param nullifierTreeRoot - The root of the nullifier tree.
 * @param contractTreeRoot - The root of the contract tree.
 * @param l1ToL2DataTreeRoot - The root of the l1 to l2 data tree.
 * @param publicDataTreeRoot - The root of the public data tree.
 * @returns The block hash.
 */
export function computeBlockHashWithGlobals(wasm, globals, privateDataTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot) {
    wasm.call('pedersen__init');
    return abisComputeBlockHashWithGlobals(wasm, globals, privateDataTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot);
}
/**
 * Computes the block hash given the blocks globals and roots.
 * @param wasm - A module providing low-level wasm access.
 * @param globalsHash - The global variables hash to put into the block hash.
 * @param privateDataTree - The root of the private data tree.
 * @param nullifierTreeRoot - The root of the nullifier tree.
 * @param contractTreeRoot - The root of the contract tree.
 * @param l1ToL2DataTreeRoot - The root of the l1 to l2 data tree.
 * @param publicDataTreeRoot - The root of the public data tree.
 * @returns The block hash.
 */
export function computeBlockHash(wasm, globalsHash, privateDataTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot) {
    wasm.call('pedersen__init');
    return abisComputeBlockHash(wasm, globalsHash, privateDataTreeRoot, nullifierTreeRoot, contractTreeRoot, l1ToL2DataTreeRoot, publicDataTreeRoot);
}
/**
 * Computes the globals hash given the globals.
 * @param wasm - A module providing low-level wasm access.
 * @param globals - The global variables to put into the block hash.
 * @returns The globals hash.
 */
export function computeGlobalsHash(wasm, globals) {
    wasm.call('pedersen__init');
    return abisComputeGlobalsHash(wasm, globals);
}
/**
 * Computes a public data tree value ready for insertion.
 * @param wasm - A module providing low-level wasm access.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export function computePublicDataTreeValue(wasm, value) {
    wasm.call('pedersen__init');
    return abisComputePublicDataTreeValue(wasm, value);
}
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param wasm - A module providing low-level wasm access.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occuring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export function computePublicDataTreeIndex(wasm, contractAddress, storageSlot) {
    wasm.call('pedersen__init');
    return abisComputePublicDataTreeIndex(wasm, contractAddress, storageSlot);
}
const ARGS_HASH_CHUNK_SIZE = 32;
const ARGS_HASH_CHUNK_COUNT = 16;
/**
 * Computes the hash of a list of arguments.
 * @param wasm - A module providing low-level wasm access.
 * @param args - Arguments to hash.
 * @returns Pedersen hash of the arguments.
 */
export function computeVarArgsHash(wasm, args) {
    if (args.length === 0)
        return Promise.resolve(Fr.ZERO);
    if (args.length > ARGS_HASH_CHUNK_SIZE * ARGS_HASH_CHUNK_COUNT)
        throw new Error(`Cannot hash more than ${ARGS_HASH_CHUNK_SIZE * ARGS_HASH_CHUNK_COUNT} arguments`);
    wasm.call('pedersen__init');
    const wasmComputeVarArgs = (args) => Fr.fromBuffer(wasmSyncCall(wasm, 'abis__compute_var_args_hash', new Vector(args), 32));
    let chunksHashes = chunk(args, ARGS_HASH_CHUNK_SIZE).map(c => {
        if (c.length < ARGS_HASH_CHUNK_SIZE) {
            c = padArrayEnd(c, Fr.ZERO, ARGS_HASH_CHUNK_SIZE);
        }
        return wasmComputeVarArgs(c);
    });
    if (chunksHashes.length < ARGS_HASH_CHUNK_COUNT) {
        chunksHashes = padArrayEnd(chunksHashes, Fr.ZERO, ARGS_HASH_CHUNK_COUNT);
    }
    return Promise.resolve(wasmComputeVarArgs(chunksHashes));
}
/**
 * Computes a contract leaf of the given contract.
 * @param wasm - Relevant WASM wrapper.
 * @param cd - The contract data of the deployed contract.
 * @returns The contract leaf.
 */
export function computeContractLeaf(wasm, cd) {
    wasm.call('pedersen__init');
    const value = wasmSyncCall(wasm, 'abis__compute_contract_leaf', cd, 32);
    return Fr.fromBuffer(value);
}
/**
 * Computes tx hash of a given transaction request.
 * @param wasm - Relevant WASM wrapper.
 * @param txRequest - The signed transaction request.
 * @returns The transaction hash.
 */
export function computeTxHash(wasm, txRequest) {
    wasm.call('pedersen__init');
    const value = wasmSyncCall(wasm, 'abis__compute_transaction_hash', txRequest, 32);
    return Fr.fromBuffer(value);
}
/**
 * Computes a call stack item hash.
 * @param wasm - Relevant WASM wrapper.
 * @param callStackItem - The call stack item.
 * @returns The call stack item hash.
 */
export function computeCallStackItemHash(wasm, callStackItem) {
    if (callStackItem instanceof PrivateCallStackItem) {
        return computePrivateCallStackItemHash(wasm, callStackItem);
    }
    else if (callStackItem instanceof PublicCallStackItem) {
        return computePublicCallStackItemHash(wasm, callStackItem);
    }
    else {
        throw new Error(`Unexpected call stack item type`);
    }
}
/**
 * Computes a call stack item hash.
 * @param wasm - Relevant WASM wrapper.
 * @param callStackItem - The call stack item.
 * @returns The call stack item hash.
 */
export function computePrivateCallStackItemHash(wasm, callStackItem) {
    wasm.call('pedersen__init');
    const value = wasmSyncCall(wasm, 'abis__compute_private_call_stack_item_hash', callStackItem, 32);
    return Fr.fromBuffer(value);
}
/**
 * Computes a call stack item hash.
 * @param wasm - Relevant WASM wrapper.
 * @param callStackItem - The call stack item.
 * @returns The call stack item hash.
 */
export function computePublicCallStackItemHash(wasm, callStackItem) {
    wasm.call('pedersen__init');
    const value = wasmSyncCall(wasm, 'abis__compute_public_call_stack_item_hash', callStackItem, 32);
    return Fr.fromBuffer(value);
}
/**
 * Computes a secret message hash for sending secret l1 to l2 messages.
 * @param secretMessage - The secret message.
 * @returns
 */
export function computeSecretMessageHash(wasm, secretMessage) {
    wasm.call('pedersen__init');
    const value = wasmSyncCall(wasm, 'abis__compute_message_secret_hash', secretMessage, 32);
    return Fr.fromBuffer(value);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJpcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmlzL2FiaXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRzNELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDaEMsT0FBTyxLQUFLLE1BQU0sY0FBYyxDQUFDO0FBRWpDLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsK0JBQStCLEVBQy9CLDBCQUEwQixFQUMxQixzQkFBc0IsRUFDdEIsOEJBQThCLEVBQzlCLDhCQUE4QixFQUM5QiwyQkFBMkIsRUFDM0Isa0JBQWtCLEVBQ2xCLGlCQUFpQixHQUNsQixNQUFNLDBCQUEwQixDQUFDO0FBQ2xDLE9BQU8sRUFDTCxZQUFZLEVBQ1osMkJBQTJCLEVBQzNCLEVBQUUsRUFLRixvQkFBb0IsRUFDcEIsbUJBQW1CLEVBR25CLE1BQU0sR0FDUCxNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVyRTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDMUIsSUFBaUIsRUFDakIsTUFBYyxFQUNkLEtBT0ssRUFDTCxvQkFBNEI7SUFFNUIsTUFBTSxTQUFTLEdBQVcsS0FBSyxZQUFZLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDN0UsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztJQUM5RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDekQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdEMsSUFBSSxD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