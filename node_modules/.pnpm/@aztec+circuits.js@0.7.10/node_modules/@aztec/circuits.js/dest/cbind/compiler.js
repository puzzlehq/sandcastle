import camelCase from 'lodash.camelcase';
import { USES_MSGPACK_BUFFER_METHODS } from './type_data.js';
/**
 * Capitalize the first character of a given string.
 * This function takes a string input and returns a new string
 * with the first character converted to uppercase, while keeping
 * the rest of the characters unchanged.
 *
 * @param s - The input string to be capitalized.
 * @returns A new string with the first character capitalized.
 */
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.substring(1);
}
/**
 * Generate a JavaScript expression to convert a given value from its Msgpack type representation to its
 * corresponding TypeScript type representation using the provided TypeInfo.
 *
 * @param typeInfo - Metadata and conversion methods related to the TypeScript and Msgpack type names.
 * @param value - The value to be converted in the generated expression.
 * @returns A JavaScript expression that converts the input value based on the provided TypeInfo.
 */
function msgpackConverterExpr(typeInfo, value) {
    const { typeName } = typeInfo;
    if (typeInfo.isAlias) {
        if (USES_MSGPACK_BUFFER_METHODS.includes(typeInfo.typeName)) {
            // TODO(AD) Temporary hack while two serialization systems exist for these classes
            return `${typeName}.fromMsgpackBuffer(${value})`;
        }
        if (typeInfo.msgpackTypeName === 'number') {
            return `${value} as ${typeName}`;
        }
        return `${typeName}.fromBuffer(${value})`;
    }
    else if (typeInfo.arraySubtype) {
        const { typeName, msgpackTypeName } = typeInfo.arraySubtype;
        const convFn = `(v: ${msgpackTypeName || typeName}) => ${msgpackConverterExpr(typeInfo.arraySubtype, 'v')}`;
        if (typeInfo.isTuple) {
            return `mapTuple(${value}, ${convFn})`;
        }
        else {
            return `${value}.map(${convFn})`;
        }
    }
    else if (typeInfo.variantSubtypes) {
        const { variantSubtypes } = typeInfo;
        // Handle the last variant type: just assume it is this type...
        let expr = msgpackConverterExpr(variantSubtypes[variantSubtypes.length - 1], 'v');
        // ... because we check every other type:
        for (let i = 0; i < variantSubtypes.length - 1; i++) {
            // mark this as needing an import
            variantSubtypes[i].usedInDiscriminatedVariant = true;
            // make the expr a compound expression with a discriminator
            expr = `(is${variantSubtypes[i].typeName}(v) ? ${msgpackConverterExpr(variantSubtypes[i], 'v')} : ${expr})`;
        }
        return `((v: ${typeInfo.msgpackTypeName}) => ${expr})(${value})`;
    }
    else if (typeInfo.mapSubtypes) {
        const { typeName, msgpackTypeName } = typeInfo.mapSubtypes[1];
        const convFn = `(v: ${msgpackTypeName || typeName}) => ${msgpackConverterExpr(typeInfo.mapSubtypes[1], 'v')}`;
        return `mapValues(${value}, ${convFn})`;
    }
    else if (typeInfo.isImport) {
        return `to${typeName}(${value})`;
    }
    else {
        return value;
    }
}
/**
 * Generate a JavaScript expression to convert a given value from its TypeScript class representation to its
 * corresponding Msgpack type representation using the provided TypeInfo.
 *
 * @param typeInfo - Metadata and conversion methods related to the TypeScript and Msgpack type names.
 * @param value - The value to be converted in the generated expression.
 * @returns A JavaScript expression that converts the input value based on the provided TypeInfo.
 */
function classConverterExpr(typeInfo, value) {
    const { typeName } = typeInfo;
    if (typeInfo.isAlias) {
        // TODO other aliases besides Buffer?
        if (USES_MSGPACK_BUFFER_METHODS.includes(typeInfo.typeName)) {
            // TODO(AD) Temporary hack while two serialization systems exist for these classes
            return `${value}.toMsgpackBuffer()`;
        }
        if (typeInfo.msgpackTypeName === 'number') {
            return `${value}`; // Should be a branded number alias
        }
        return `toBuffer(${value})`;
    }
    else if (typeInfo.arraySubtype) {
        const { typeName } = typeInfo.arraySubtype;
        const convFn = `(v: ${typeName}) => ${classConverterExpr(typeInfo.arraySubtype, 'v')}`;
        if (typeInfo.isTuple) {
            return `mapTuple(${value}, ${convFn})`;
        }
        else {
            return `${value}.map(${convFn})`;
        }
    }
    else if (typeInfo.variantSubtypes) {
        throw new Error('TODO - variant parameters to C++ not yet supported');
    }
    else if (typeInfo.mapSubtypes) {
        const { typeName } = typeInfo.mapSubtypes[1];
        const convFn = `(v: ${typeName}) => ${classConverterExpr(typeInfo.mapSubtypes[1], 'v')}`;
        return `mapValues(${value}, ${convFn})`;
    }
    else if (typeInfo.isImport) {
        return `from${typeName}(${value})`;
    }
    else {
        return value;
    }
}
/**
 * Converts a spec emitted from the WASM.
 * Creates typescript code.
 */
export class CbindCompiler {
    constructor() {
        // Function and declaration output fragments
        this.typeInfos = {};
        // cbind outputs, put at end
        this.funcDecls = [];
    }
    /**
     * Retrieve the TypeScript type name for a given schema.
     * This function utilizes the TypeInfo cache to obtain the appropriate type name
     * and handles any necessary type compilation along the way.
     *
     * @param type - The input schema for which to retrieve the TypeScript type name.
     * @returns The corresponding TypeScript type name as a string.
     */
    getTypeName(type) {
        return this.getTypeInfo(type).typeName;
    }
    /**
     * Derive the TypeScript type name of a schema, compiling anything needed along the way.
     * @param type - A schema.
     * @returns The type name.
     */
    getTypeInfo(type) {
        if (Array.isArray(type)) {
            if (type[0] === 'array') {
                // fixed-size array case
                const [_array, [subtype, size]] = type;
                const typeName = `Tuple<${this.getTypeName(subtype)}, ${size}>`;
                const msgpackTypeName = `Tuple<${this.getMsgpackTypename(subtype)}, ${size}>`;
                return {
                    typeName,
                    msgpackTypeName,
                    isTuple: true,
                    arraySubtype: this.getTypeInfo(subtype),
                };
            }
            else if (type[0] === 'variant') {
                // fixed-size array case
                const [_array, variantSchemas] = type;
                const typeName = variantSchemas.map(vs => this.getTypeName(vs)).join(' | ');
                const msgpackTypeName = variantSchemas.map(vs => this.getMsgpackTypename(vs)).join(' | ');
                return {
                    typeName,
                    msgpackTypeName,
                    variantSubtypes: variantSchemas.map(vs => this.getTypeInfo(vs)),
                };
            }
            else if (type[0] === 'vector') {
                // vector case
                const [_vector, [subtype]] = type;
                if (subtype == 'unsigned char') {
                    // buffer special case
                    return { typeName: 'Buffer' };
                }
                const subtypeInfo = this.getTypeInfo(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${this.getMsgpackTypename(subtype)}[]`,
                    arraySubtype: subtypeInfo,
                };
            }
            else if (type[0] === 'alias') {
                // alias case
                const [_alias, [rawTypeName, msgpackName]] = type;
                let msgpackTypeName;
                if (msgpackName.startsWith('bin')) {
                    msgpackTypeName = 'Buffer';
                }
                else if (msgpackName === 'int' || msgpackName === 'unsigned int' || msgpackName === 'unsigned short') {
                    msgpackTypeName = 'number';
                }
                else {
                    throw new Error('Unsupported alias type ' + msgpackName);
                }
                const typeName = capitalize(camelCase(rawTypeName));
                this.typeInfos[typeName] = {
                    typeName,
                    isImport: true,
                    isAlias: true,
                    msgpackTypeName,
                };
                return this.typeInfos[typeName];
            }
            else if (type[0] === 'shared_ptr') {
                // shared_ptr case
                const [_sharedPtr, [subtype]] = type;
                return this.getTypeInfo(subtype);
            }
            else if (type[0] === 'map') {
                // map case
                const [_map, [keyType, valueType]] = type;
                return {
                    typeName: `Record<${this.getTypeName(keyType)}, ${this.getTypeName(valueType)}>`,
                    msgpackTypeName: `Record<${this.getMsgpackTypename(keyType)}, ${this.getMsgpackTypename(valueType)}>`,
                    mapSubtypes: [this.getTypeInfo(keyType), this.getTypeInfo(valueType)],
                };
            }
        }
        else if (typeof type === 'string') {
            switch (type) {
                case 'bool':
                    return { typeName: 'boolean' };
                case 'int':
                case 'unsigned int':
                case 'unsigned short':
                    return { typeName: 'number' };
                case 'string':
                    return { typeName: 'string' };
                case 'bin32':
                    return { typeName: 'Buffer' };
            }
            const typeName = capitalize(camelCase(type));
            if (!this.typeInfos[typeName]) {
                throw new Error('Unexpected type: ' +
                    typeName +
                    '. This is likely due to returning a struct without a MSGPACK_FIELDS macro, and without a msgpack_schema method.');
            }
            return this.typeInfos[typeName];
        }
        else if (typeof type === 'object') {
            const typeName = capitalize(camelCase(type.__typename));
            // Set our typeInfos object to either what it already was, or, if not yet defined
            // the resolved type info (which will generate interfaces and helper methods)
            return (this.typeInfos[typeName] = this.typeInfos[typeName] || {
                typeName,
                msgpackTypeName: 'Msgpack' + typeName,
                isImport: true,
                declaration: this.generateInterface(typeName, type),
                toClassMethod: this.generateMsgpackConverter(typeName, type),
                fromClassMethod: this.generateClassConverter(typeName, type),
            });
        }
        throw new Error(`Unsupported type: ${type}`);
    }
    /**
     * Retrieve the Msgpack type name for a given schema.
     * This function returns the MsgpackTypeName if available, or the default TypeName otherwise.
     * It is useful for handling cases where the Msgpack type representation differs from the TypeScript type,
     * ensuring proper serialization and deserialization between the two formats.
     *
     * @param schema - The schema for which the Msgpack type name is required.
     * @returns The Msgpack type name corresponding to the input schema.
     */
    getMsgpackTypename(schema) {
        const { msgpackTypeName, typeName } = this.getTypeInfo(schema);
        return msgpackTypeName || typeName;
    }
    /**
     * Generate an interface with the name 'name'.
     * @param name - The interface name.
     * @param type - The object schema with properties of the interface.
     * @returns the interface body.
     */
    generateInterface(name, type) {
        // Raw object, used as return value of fromType() generated functions.
        let result = `interface Msgpack${name} {\n`;
        for (const [key, value] of Object.entries(type)) {
            if (key === '__typename')
                continue;
            result += `  ${key}: ${this.getMsgpackTypename(value)};\n`;
        }
        result += '}';
        return result;
    }
    /**
     * Generate conversion method 'toName' for a specific type 'name'.
     * @param name - The class name.
     * @param type - The object schema with properties of the interface.
     * @returns The toName method.
     */
    generateMsgpackConverter(name, type) {
        const typename = capitalize(camelCase(type.__typename));
        const checkerSyntax = () => {
            const statements = [];
            for (const [key] of Object.entries(type)) {
                if (key === '__typename')
                    continue;
                statements.push(`  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${typename} deserialization"); }`);
            }
            return statements.join('\n');
        };
        // TODO should we always just call constructor?
        const constructorBodySyntax = () => {
            const statements = [];
            for (const [key, value] of Object.entries(type)) {
                if (key === '__typename')
                    continue;
                statements.push(`  ${msgpackConverterExpr(this.getTypeInfo(value), `o.${key}`)},`);
            }
            return statements.join('\n');
        };
        const callSyntax = () => {
            // return `${name}.from({\n${objectBodySyntax()}})`;
            return `new ${name}(\n${constructorBodySyntax()})`;
        };
        return `export function to${name}(o: Msgpack${name}): ${name} {
${checkerSyntax()};
return ${callSyntax.call(this)};
}`;
    }
    /**
     * Generate conversion method 'fromName' for a specific type 'name'.
     * @param name - The class name.
     * @param type - The object schema with properties of the interface.
     * @returns the fromName method string.
     */
    generateClassConverter(name, type) {
        const typename = capitalize(camelCase(type.__typename));
        const checkerSyntax = () => {
            const statements = [];
            for (const [key] of Object.entries(type)) {
                if (key === '__typename')
                    continue;
                statements.push(`  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${typename} serialization"); }`);
            }
            return statements.join('\n');
        };
        const bodySyntax = () => {
            const statements = [];
            for (const [key, value] of Object.entries(type)) {
                if (key === '__typename')
                    continue;
                statements.push(`  ${key}: ${classConverterExpr(this.getTypeInfo(value), `o.${camelCase(key)}`)},`);
            }
            return statements.join('\n');
        };
        const callSyntax = () => {
            return `{\n${bodySyntax()}}`;
        };
        return `export function from${name}(o: ${name}): Msgpack${name} {
${checkerSyntax()};
return ${callSyntax.call(this)};
}`;
    }
    /**
     * Process a cbind schema.
     * @param name - The cbind name.
     * @param cbind - The cbind schema.
     * @returns The compiled schema.
     */
    processCbind(name, cbind) {
        const [_tuple, args] = cbind.args;
        const typeInfos = args.map(arg => this.getTypeInfo(arg));
        const argStrings = typeInfos.map((typeInfo, i) => `arg${i}: ${typeInfo.typeName}`);
        const callStrings = typeInfos.map((typeInfo, i) => `${classConverterExpr(typeInfo, `arg${i}`)}`);
        const innerCall = `callCbind(wasm, '${name}', [${callStrings.join(', ')}])`;
        const retType = this.getTypeInfo(cbind.ret);
        this.funcDecls.push(`export function ${camelCase(name)}(wasm: IWasmModule, ${argStrings.join(', ')}): ${retType.typeName} {
return ${msgpackConverterExpr(retType, innerCall)};
}`);
    }
    /**
     * Compile the generated TypeScript code from processed cbind schemas into a single string.
     * The output string consists of necessary imports, type declarations, and helper methods
     * for serialization and deserialization between TypeScript classes and Msgpack format,
     * as well as the compiled cbind function calls.
     *
     * @returns A string containing the complete compiled TypeScript code.
     */
    compile() {
        const imports = [];
        const outputs = [
            `
/* eslint-disable */
// GENERATED FILE DO NOT EDIT, RUN yarn remake-bindings
import { Buffer } from "buffer";
import { callCbind } from './cbind.js';
import { IWasmModule } from '@aztec/foundation/wasm';
`,
        ];
        for (const typeInfo of Object.values(this.typeInfos)) {
            if (typeInfo.isImport) {
                imports.push(typeInfo.typeName);
            }
            if (typeInfo.usedInDiscriminatedVariant) {
                imports.push(`is${typeInfo.typeName}`);
            }
            if (typeInfo.declaration) {
                outputs.push(typeInfo.declaration);
                outputs.push('\n');
            }
            if (typeInfo.toClassMethod) {
                outputs.push(typeInfo.toClassMethod);
                outputs.push('\n');
            }
            if (typeInfo.fromClassMethod) {
                outputs.push(typeInfo.fromClassMethod);
                outputs.push('\n');
            }
        }
        outputs[0] += `
import {toBuffer, ${imports.join(', ')}} from './types.js';
import {Tuple, mapTuple} from '@aztec/foundation/serialize';
import mapValues from 'lodash.mapvalues';
       `;
        for (const funcDecl of Object.values(this.funcDecls)) {
            outputs.push(funcDecl);
        }
        return outputs.join('\n');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2JpbmQvY29tcGlsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTLE1BQU0sa0JBQWtCLENBQUM7QUFFekMsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0Q7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUE4RkQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsb0JBQW9CLENBQUMsUUFBa0IsRUFBRSxLQUFhO0lBQzdELE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxRQUFRLENBQUM7SUFDOUIsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFO1FBQ3BCLElBQUksMkJBQTJCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMzRCxrRkFBa0Y7WUFDbEYsT0FBTyxHQUFHLFFBQVEsc0JBQXNCLEtBQUssR0FBRyxDQUFDO1NBQ2xEO1FBQ0QsSUFBSSxRQUFRLENBQUMsZUFBZSxLQUFLLFFBQVEsRUFBRTtZQUN6QyxPQUFPLEdBQUcsS0FBSyxPQUFPLFFBQVEsRUFBRSxDQUFDO1NBQ2xDO1FBQ0QsT0FBTyxHQUFHLFFBQVEsZUFBZSxLQUFLLEdBQUcsQ0FBQztLQUMzQztTQUFNLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRTtRQUNoQyxNQUFNLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDNUQsTUFBTSxNQUFNLEdBQUcsT0FBTyxlQUFlLElBQUksUUFBUSxRQUFRLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFD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