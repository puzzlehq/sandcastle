/**
 * Represents an object schema where keys are mapped to their corresponding type schemas, defining a structured data model.
 */
type ObjectSchema = {
    [key: string]: Schema;
};
/**
 * Represents the various data structures and types used to model schema definitions.
 * The Schema type supports primitive types, object schemas, tuples, maps, optional values,
 * fixed-size arrays, shared pointers, and custom type aliases (defined in schema_map_impl.hpp).
 */
type Schema = string | ObjectSchema | ['tuple', Schema[]] | ['map', [Schema, Schema]] | ['optional', [Schema]] | ['vector', [Schema]] | ['variant', Schema[]] | ['shared_ptr', [Schema]] | ['array', [Schema, number]] | ['alias', [string, string]];
/**
 * Represents a detailed description of a schema's type information.
 * Provides metadata and conversion methods related to the TypeScript and Msgpack type names,
 * as well as any required dependencies or custom behavior for specific schemas.
 */
export interface TypeInfo {
    /**
     * High-level typescript type name.
     */
    typeName: string;
    /**
     * Msgpack type name. The actual type returned by raw C-binds.
     * Only given if different.
     */
    msgpackTypeName?: string;
    /**
     * Indicates if the schema requires an interface.
     */
    needsInterface?: boolean;
    /**
     * Indicates if the schema refers to an imported type.
     */
    isImport?: boolean;
    /**
     * Indicates if the type is an alias of another type.
     */
    isAlias?: boolean;
    /**
     * Indicates if the schema represents a tuple type.
     */
    isTuple?: boolean;
    /**
     * Indicates if the schama represents an array.
     * If so, stores the array's subtype elements.
     */
    arraySubtype?: TypeInfo;
    /**
     * Indicates if the schama represents a variant.
     * If so, stores the variant's subtype elements.
     */
    variantSubtypes?: TypeInfo[];
    /**
     * Was this used in a variant type?
     * Typically a variant in C++ will have an easy to distinguish type as
     * one of two structs e.g. [Error, T]. In that case, a isError method would be imported. Only if a third type was
     * added would we need to distinguish T as well.
     */
    usedInDiscriminatedVariant?: boolean;
    /**
     * Key-value pair of types that represent the keys and values in a map schema.
     */
    mapSubtypes?: [TypeInfo, TypeInfo];
    /**
     * Represents the TypeScript interface declaration for a specific schema type.
     */
    declaration?: string;
    /**
     * Conversion method to transform Msgpack data into a class instance.
     */
    toClassMethod?: string;
    /**
     * Converts a class instance to its Msgpack representation.
     */
    fromClassMethod?: string;
    /**
     * Represents the conversion method from class to Msgpack format.
     */
    toMsgpackMethod?: string;
}
/**
 * Converts a spec emitted from the WASM.
 * Creates typescript code.
 */
export declare class CbindCompiler {
    private typeInfos;
    private funcDecls;
    /**
     * Retrieve the TypeScript type name for a given schema.
     * This function utilizes the TypeInfo cache to obtain the appropriate type name
     * and handles any necessary type compilation along the way.
     *
     * @param type - The input schema for which to retrieve the TypeScript type name.
     * @returns The corresponding TypeScript type name as a string.
     */
    private getTypeName;
    /**
     * Derive the TypeScript type name of a schema, compiling anything needed along the way.
     * @param type - A schema.
     * @returns The type name.
     */
    private getTypeInfo;
    /**
     * Retrieve the Msgpack type name for a given schema.
     * This function returns the MsgpackTypeName if available, or the default TypeName otherwise.
     * It is useful for handling cases where the Msgpack type representation differs from the TypeScript type,
     * ensuring proper serialization and deserialization between the two formats.
     *
     * @param schema - The schema for which the Msgpack type name is required.
     * @returns The Msgpack type name corresponding to the input schema.
     */
    private getMsgpackTypename;
    /**
     * Generate an interface with the name 'name'.
     * @param name - The interface name.
     * @param type - The object schema with properties of the interface.
     * @returns the interface body.
     */
    private generateInterface;
    /**
     * Generate conversion method 'toName' for a specific type 'name'.
     * @param name - The class name.
     * @param type - The object schema with properties of the interface.
     * @returns The toName method.
     */
    private generateMsgpackConverter;
    /**
     * Generate conversion method 'fromName' for a specific type 'name'.
     * @param name - The class name.
     * @param type - The object schema with properties of the interface.
     * @returns the fromName method string.
     */
    private generateClassConverter;
    /**
     * Process a cbind schema.
     * @param name - The cbind name.
     * @param cbind - The cbind schema.
     * @returns The compiled schema.
     */
    processCbind(name: string, cbind: {
        /**
         * An array of Schema representing the argument types for a cbind function.
         */
        args: ['tuple', Schema[]];
        /**
         * The returned value's schema after processing the cbind.
         */
        ret: Schema;
    }): void;
    /**
     * Compile the generated TypeScript code from processed cbind schemas into a single string.
     * The output string consists of necessary imports, type declarations, and helper methods
     * for serialization and deserialization between TypeScript classes and Msgpack format,
     * as well as the compiled cbind function calls.
     *
     * @returns A string containing the complete compiled TypeScript code.
     */
    compile(): string;
}
export {};
//# sourceMappingURL=compiler.d.ts.map