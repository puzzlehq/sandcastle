/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '@aztec/circuits.js/utils';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
/**
 * Interface of classes allowing for the retrieval of L1 to L2 messages.
 */
export interface L1ToL2MessageSource {
    /**
     * Gets up to `limit` amount of pending L1 to L2 messages, sorted by fee
     * @param limit - The maximum number of messages to return (by default NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP).
     * @returns The requested L1 to L2 messages' keys.
     */
    getPendingL1ToL2Messages(limit?: number): Promise<Fr[]>;
    /**
     * Gets the confirmed L1 to L2 message with the given message key.
     * i.e. message that has already been consumed by the sequencer and published in an L2 Block
     * @param messageKey - The message key.
     * @returns The confirmed L1 to L2 message (throws if not found)
     */
    getConfirmedL1ToL2Message(messageKey: Fr): Promise<L1ToL2Message>;
}
/**
 * L1AndL2Message and Index (in the merkle tree) as one type
 */
export type L1ToL2MessageAndIndex = {
    /**
     * The message.
     */
    message: L1ToL2Message;
    /**
     * the index in the L1 to L2 Message tree.
     */
    index: bigint;
};
/**
 * The format of an L1 to L2 Message.
 */
export declare class L1ToL2Message {
    /**
     * The sender of the message on L1.
     */
    readonly sender: L1Actor;
    /**
     * The recipient of the message on L2.
     */
    readonly recipient: L2Actor;
    /**
     * The message content.
     */
    readonly content: Fr;
    /**
     * The hash of the spending secret.
     */
    readonly secretHash: Fr;
    /**
     * The deadline for the message.
     */
    readonly deadline: number;
    /**
     * The fee for the message.
     */
    readonly fee: number;
    /**
     * The entry key for the message - optional.
     */
    readonly entryKey?: Fr | undefined;
    constructor(
    /**
     * The sender of the message on L1.
     */
    sender: L1Actor, 
    /**
     * The recipient of the message on L2.
     */
    recipient: L2Actor, 
    /**
     * The message content.
     */
    content: Fr, 
    /**
     * The hash of the spending secret.
     */
    secretHash: Fr, 
    /**
     * The deadline for the message.
     */
    deadline: number, 
    /**
     * The fee for the message.
     */
    fee: number, 
    /**
     * The entry key for the message - optional.
     */
    entryKey?: Fr | undefined);
    /**
     * Returns each element within its own field so that it can be consumed by an acvm oracle call.
     * @returns The message as an array of fields (in order).
     */
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L1ToL2Message;
    static empty(): L1ToL2Message;
    static random(): L1ToL2Message;
}
/**
 * The sender of an L1 to L2 message.
 */
export declare class L1Actor {
    /**
     * The sender of the message.
     */
    readonly sender: EthAddress;
    /**
     * The chain id on which the message was sent.
     */
    readonly chainId: number;
    constructor(
    /**
     * The sender of the message.
     */
    sender: EthAddress, 
    /**
     * The chain id on which the message was sent.
     */
    chainId: number);
    static empty(): L1Actor;
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L1Actor;
    static random(): L1Actor;
}
/**
 * The recipient of an L2 message.
 */
export declare class L2Actor {
    /**
     * The recipient of the message.
     */
    readonly recipient: AztecAddress;
    /**
     * The version of the protocol.
     */
    readonly version: number;
    constructor(
    /**
     * The recipient of the message.
     */
    recipient: AztecAddress, 
    /**
     * The version of the protocol.
     */
    version: number);
    static empty(): L2Actor;
    toFieldArray(): Fr[];
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): L2Actor;
    static random(): L2Actor;
}
//# sourceMappingURL=l1_to_l2_message.d.ts.map