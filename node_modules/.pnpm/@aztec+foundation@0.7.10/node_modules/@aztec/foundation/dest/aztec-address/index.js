import { toBigIntBE, toBufferBE } from '../bigint-buffer/index.js';
import { Fr } from '../fields/index.js';
import { BufferReader } from '../serialize/buffer_reader.js';
/**
 * AztecAddress represents a 32-byte address in the Aztec Protocol. It provides methods to create, manipulate, and
 * compare addresses. The maximum value of an address is determined by the field modulus and all instances of AztecAddress
 * should have a value less than or equal to this max value. This class also provides helper functions to convert
 * addresses from strings, buffers, and other formats.
 */
export class AztecAddress {
    constructor(
    /**
     * The buffer field.
     */
    buffer) {
        this.buffer = buffer;
        const value = toBigIntBE(buffer);
        if (value > AztecAddress.MAX_VALUE) {
            throw new Error(`AztecAddress out of range ${value}.`);
        }
    }
    /**
     * Generates a random AztecAddress instance, using the Fr field (a finite field) to create a random value
     * within a valid range and then converting it into a Buffer of a fixed size in bytes.
     *
     * @returns A new AztecAddress instance with a random value.
     */
    static random() {
        return new AztecAddress(toBufferBE(Fr.random().value, AztecAddress.SIZE_IN_BYTES));
    }
    /**
     * Creates an AztecAddress instance from a given buffer or BufferReader.
     * If the input is a Buffer, it wraps it in a BufferReader before processing.
     * Throws an error if the input length is not equal to the expected size.
     *
     * @param buffer - The input buffer or BufferReader containing the address data.
     * @returns - A new AztecAddress instance with the extracted address data.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new this(reader.readBytes(this.SIZE_IN_BYTES));
    }
    /**
     * Create an AztecAddress instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 64 hex characters.
     * Throws an error if the input length is invalid or address value is out of range.
     *
     * @param address - The hex-encoded string representing the Aztec address.
     * @returns An AztecAddress instance.
     */
    static fromString(address) {
        const buf = Buffer.from(address.replace(/^0x/i, ''), 'hex');
        if (buf.length !== AztecAddress.SIZE_IN_BYTES) {
            throw new Error(`Invalid length ${buf.length}.`);
        }
        return new AztecAddress(buf);
    }
    /**
     * Creates an AztecAddress from a bigint.
     * The provided value must be within the range of a field.
     * @param address - The bigint representation of the address.
     * @returns An AztecAddress instance.
     */
    static fromBigInt(address) {
        return new AztecAddress(toBufferBE(address, AztecAddress.SIZE_IN_BYTES));
    }
    /**
     * Converts the AztecAddress instance into a Buffer.
     * This method should be used when encoding the address for storage, transmission or serialization purposes.
     *
     * @returns A Buffer representation of the AztecAddress instance.
     */
    toBuffer() {
        return this.buffer;
    }
    /**
     * Convert the AztecAddress to a hexadecimal string representation, with a "0x" prefix.
     * The resulting string will have a length of 66 characters (including the prefix).
     *
     * @returns A hexadecimal string representation of the AztecAddress.
     */
    toString() {
        return `0x${this.buffer.toString('hex')}`;
    }
    /**
     * Returns a shortened string representation of the AztecAddress, displaying only the first 10 characters and last 4 characters.
     * This is useful for human-readable displays where the full address is not necessary.
     *
     * @returns A shortened string representation of the address.
     */
    toShortString() {
        const str = this.toString();
        return `${str.slice(0, 10)}...${str.slice(-4)}`;
    }
    /**
     * Returns this address from a Field element.
     * @param field - The Field element to convert.
     * @returns An Address Object from a Field element with the same value.
     */
    static fromField(field) {
        return new AztecAddress(toBufferBE(field.value, AztecAddress.SIZE_IN_BYTES));
    }
    /**
     * Returns this address as a field element.
     * @returns A field element with the same value as the address.
     */
    toField() {
        return Fr.fromBuffer(this.toBuffer());
    }
    /**
     * Returns this address as a bigint. Useful for creating maps indexed by addresses.
     * @returns A bigint with the same value as the address.
     */
    toBigInt() {
        return toBigIntBE(this.buffer);
    }
    /**
     * Determines if this AztecAddress instance is equal to the given AztecAddress instance.
     * Equality is based on the content of their respective buffers.
     *
     * @param other - The AztecAddress instance to compare against.
     * @returns True if the buffers of both instances are equal, false otherwise.
     */
    equals(other) {
        return this.buffer.equals(other.buffer);
    }
    /**
     * Checks if the AztecAddress is zero.
     *
     * @returns Returns true if the AztecAddress is equal to the zero address, otherwise returns false.
     */
    isZero() {
        return this.equals(AztecAddress.ZERO);
    }
    /**
     * Friendly representation for debugging purposes.
     *
     * @returns A hex string representing the address.
     */
    toFriendlyJSON() {
        return this.toString();
    }
}
AztecAddress.SIZE_IN_BYTES = 32;
AztecAddress.ZERO = new AztecAddress(Buffer.alloc(AztecAddress.SIZE_IN_BYTES));
AztecAddress.MODULUS = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n;
AztecAddress.MAX_VALUE = AztecAddress.MODULUS - 1n;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXp0ZWMtYWRkcmVzcy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ25FLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFN0Q7Ozs7O0dBS0c7QUFDSCxNQUFNLE9BQU8sWUFBWTtJQU12QjtJQUNFOztPQUVHO0lBQ2EsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFFOUIsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLElBQUksS0FBSyxHQUFHLFlBQVksQ0FBQyxTQUFTLEVBQUU7WUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsS0FBSyxHQUFHLENBQUMsQ0FBQztTQUN4RDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxNQUFNO1FBQ1gsT0FBTyxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBNkI7UUFDN0MsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQWU7UUFDL0IsTUFBTSxHQUFHLEdBQUcs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