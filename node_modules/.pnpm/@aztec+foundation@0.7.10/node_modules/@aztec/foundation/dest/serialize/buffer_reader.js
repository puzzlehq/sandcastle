import { Fq, Fr } from '../fields/fields.js';
/**
 * The BufferReader class provides a utility for reading various data types from a buffer.
 * It supports reading numbers, booleans, byte arrays, Fr and Fq field elements,
 * vectors, arrays, objects, strings, and maps. It maintains an internal index to
 * keep track of the current reading position in the buffer.
 *
 * Usage:
 * Create a new instance of BufferReader with a buffer and an optional offset.
 * Use the provided methods to read desired data types from the buffer.
 * The reading methods automatically advance the internal index.
 *
 * @example
 * const reader = new BufferReader(someBuffer);
 * const num = reader.readNumber();
 * const bool = reader.readBoolean();
 * const byteArray = reader.readBytes(4);
 */
export class BufferReader {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.index = offset;
    }
    /**
     * Creates a BufferReader instance from either a Buffer or an existing BufferReader.
     * If the input is a Buffer, it creates a new BufferReader with the given buffer.
     * If the input is already a BufferReader, it returns the input unchanged.
     *
     * @param bufferOrReader - A Buffer or BufferReader to initialize the BufferReader.
     * @returns An instance of BufferReader.
     */
    static asReader(bufferOrReader) {
        return Buffer.isBuffer(bufferOrReader) ? new BufferReader(bufferOrReader) : bufferOrReader;
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer at the current index position.
     * Updates the index position by 4 bytes after reading the number.
     *
     * @returns The read 32-bit unsigned integer value.
     */
    readNumber() {
        this.index += 4;
        return this.buffer.readUint32BE(this.index - 4);
    }
    /**
     * Reads a 16-bit unsigned integer from the buffer at the current index position.
     * Updates the index position by 2 bytes after reading the number.
     *
     * @returns The read 16 bit value.
     */
    readUInt16() {
        this.index += 2;
        return this.buffer.readUInt16BE(this.index - 2);
    }
    /**
     * Reads and returns the next boolean value from the buffer.
     * Advances the internal index by 1, treating the byte at the current index as a boolean value.
     * Returns true if the byte is non-zero, false otherwise.
     *
     * @returns A boolean value representing the byte at the current index.
     */
    readBoolean() {
        this.index += 1;
        return Boolean(this.buffer.at(this.index - 1));
    }
    /**
     * Reads a specified number of bytes from the buffer and returns a new Buffer containing those bytes.
     * Advances the reader's index by the number of bytes read. Throws an error if there are not enough
     * bytes left in the buffer to satisfy the requested number of bytes.
     *
     * @param n - The number of bytes to read from the buffer.
     * @returns A new Buffer containing the read bytes.
     */
    readBytes(n) {
        this.index += n;
        return Buffer.from(this.buffer.subarray(this.index - n, this.index));
    }
    /**
     * Reads a Fr (finite field) element from the buffer using the 'fromBuffer' method of the Fr class.
     * The Fr class should provide a 'fromBuffer' method that takes a BufferReader instance as input.
     *
     * @returns An instance of the Fr class representing the finite field element.
     */
    readFr() {
        return Fr.fromBuffer(this);
    }
    /**
     * Reads the next Fq element from the buffer using the Fq.fromBuffer method.
     * The Fq element represents a finite field in elliptic curve cryptography and is used for calculations.
     * Advances the internal buffer index by the number of bytes read.
     *
     * @returns An Fq instance representing the finite field element.
     */
    readFq() {
        return Fq.fromBuffer(this);
    }
    /**
     * Reads a vector of numbers from the buffer and returns it as an array of numbers.
     * The method utilizes the 'readVector' method, passing a deserializer that reads numbers.
     *
     * @returns An array of numbers representing the vector read from the buffer.
     */
    readNumberVector() {
        return this.readVector({
            fromBuffer: (reader) => reader.readNumber(),
        });
    }
    /**
     * Reads a vector of fixed size from the buffer and deserializes its elements using the provided itemDeserializer object.
     * The 'itemDeserializer' object should have a 'fromBuffer' method that takes a BufferReader instance and returns the deserialized element.
     * The method first reads the size of the vector (a number) from the buffer, then iterates through its elements,
     * deserializing each one using the 'fromBuffer' method of 'itemDeserializer'.
     *
     * @param itemDeserializer - Object with 'fromBuffer' method to deserialize vector elements.
     * @returns An array of deserialized elements of type T.
     */
    readVector(itemDeserializer) {
        const size = this.readNumber();
        const result = new Array(size);
        for (let i = 0; i < size; i++) {
            result[i] = itemDeserializer.fromBuffer(this);
        }
        return result;
    }
    /**
     * Read an array of a fixed size with elements of type T from the buffer.
     * The 'itemDeserializer' object should have a 'fromBuffer' method that takes a BufferReader instance as input,
     * and returns an instance of the desired deserialized data type T.
     * This method will call the 'fromBuffer' method for each element in the array and return the resulting array.
     *
     * @param size - The fixed number of elements in the array.
     * @param itemDeserializer - An object with a 'fromBuffer' method to deserialize individual elements of type T.
     * @returns An array of instances of type T.
     */
    readArray(size, itemDeserializer) {
        const result = Array.from({ length: size }, () => itemDeserializer.fromBuffer(this));
        return result;
    }
    /**
     * Read a variable sized Buffer array where elements are represented by length + data.
     * The method consecutively looks for a number which is the size of the proceeding buffer,
     * then reads the bytes until it reaches the end of the reader's internal buffer.
     * NOTE: if `size` is not provided, this will run to the end of the reader's buffer.
     * @param size - Size of the buffer array in bytes (full remaining buffer length if left empty).
     * @returns An array of variable sized buffers.
     */
    readBufferArray(size = -1) {
        const result = [];
        const end = size >= 0 ? this.index + size : this.buffer.length;
        while (this.index < end) {
            const item = this.readBuffer();
            result.push(item);
        }
        // Ensure that all bytes have been read.
        if (this.index !== end) {
            throw new Error(`Reader buffer was not fully consumed. Consumed up to ${this.index} bytes. End of data: ${end} bytes.`);
        }
        return result;
    }
    /**
     * Reads a serialized object from a buffer and returns the deserialized object using the given deserializer.
     *
     * @typeparam T - The type of the deserialized object.
     * @param deserializer - An object with a 'fromBuffer' method that takes a BufferReader instance and returns an instance of the deserialized object.
     * @returns The deserialized object of type T.
     */
    readObject(deserializer) {
        return deserializer.fromBuffer(this);
    }
    /**
     * Returns a Buffer containing the next n bytes from the current buffer without modifying the reader's index position.
     * If n is not provided or exceeds the remaining length of the buffer, it returns all bytes from the current position till the end of the buffer.
     *
     * @param n - The number of bytes to peek from the current buffer. (Optional).
     * @returns A Buffer with the next n bytes or the remaining bytes if n is not provided or exceeds the buffer length.
     */
    peekBytes(n) {
        return this.buffer.subarray(this.index, n ? this.index + n : undefined);
    }
    /**
     * Reads a string from the buffer and returns it.
     * The method first reads the size of the string, then reads the corresponding
     * number of bytes from the buffer and converts them to a string.
     *
     * @returns The read string from the buffer.
     */
    readString() {
        return this.readBuffer().toString();
    }
    /**
     * Reads a buffer from the current position of the reader and advances the index.
     * The method first reads the size (number) of bytes to be read, and then returns
     * a Buffer with that size containing the bytes. Useful for reading variable-length
     * binary data encoded as (size, data) format.
     *
     * @returns A Buffer containing the read bytes.
     */
    readBuffer() {
        const size = this.readNumber();
        return this.readBytes(size);
    }
    /**
     * Reads and constructs a map object from the current buffer using the provided deserializer.
     * The method reads the number of entries in the map, followed by iterating through each key-value pair.
     * The key is read as a string, while the value is obtained using the passed deserializer's `fromBuffer` method.
     * The resulting map object is returned, containing all the key-value pairs read from the buffer.
     *
     * @param deserializer - An object with a `fromBuffer` method to deserialize the values in the map.
     * @returns A map object with string keys and deserialized values based on the provided deserializer.
     */
    readMap(deserializer) {
        const numEntries = this.readNumber();
        const map = {};
        for (let i = 0; i < numEntries; i++) {
            const key = this.readString();
            const value = this.readObject(deserializer);
            map[key] = value;
        }
        return map;
    }
    /**
     * Get the length of the reader's buffer.
     * @returns The length of the underlying reader's buffer.
     */
    getLength() {
        return this.buffer.length;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVmZmVyX3JlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zZXJpYWxpemUvYnVmZmVyX3JlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRzdDOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxPQUFPLFlBQVk7SUFFdkIsWUFBb0IsTUFBYyxFQUFFLE1BQU0sR0FBRyxDQUFDO1FBQTFCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLGNBQXFDO1FBQzFELE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztJQUM3RixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVO1FBQ2YsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDaEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFVBQVU7UUFDZixJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztRQUNoQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFdBQVc7UUFDaEIsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDaEIsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFF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