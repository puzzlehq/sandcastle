import { deserializeArrayFromVector, deserializeBigInt, deserializeBool, deserializeBufferFromVector, deserializeInt32, deserializeUInt32, } from './free_funcs.js';
/**
 * Deserializer class provides a set of methods to deserialize different data types from a buffer.
 * It maintains an internal buffer and offset, updating the offset as it deserializes each data type.
 * The class supports deserialization of various data types including boolean, integers, big integers,
 * buffers, strings, dates, and arrays with custom deserialization functions.
 *
 * @example
 * const deserializer = new Deserializer(buffer);
 * const boolValue = deserializer.bool();
 * const intValue = deserializer.int32();
 * const bigIntValue = deserializer.bigInt();
 * const stringValue = deserializer.string();
 * const dateValue = deserializer.date();
 * const arrayValue = deserializer.deserializeArray(customDeserializeFn);
 */
export class Deserializer {
    constructor(buf, offset = 0) {
        this.buf = buf;
        this.offset = offset;
    }
    /**
     * Deserialize a boolean value from the buffer at the current offset.
     * Advances the internal offset by one byte after deserialization.
     * Returns 'true' if the deserialized value is non-zero, otherwise returns 'false'.
     *
     * @returns The deserialized boolean value.
     */
    bool() {
        return this.exec(deserializeBool) ? true : false;
    }
    /**
     * Deserialize a 32-bit unsigned integer from the buffer at the current offset.
     * Advances the internal buffer offset by 4 after successful deserialization.
     * The result is returned as a JavaScript number.
     *
     * @returns A 32-bit unsigned integer value.
     */
    uInt32() {
        return this.exec(deserializeUInt32);
    }
    /**
     * Deserialize a 32-bit signed integer from the internal buffer.
     * Reads 4 bytes from the current offset in the buffer and interprets them as a little-endian int32 value.
     * Advances the internal offset by 4 bytes after successful deserialization.
     *
     * @returns The deserialized 32-bit signed integer value.
     */
    int32() {
        return this.exec(deserializeInt32);
    }
    /**
     * Deserialize a BigInt from the buffer, taking into account the specified width.
     * The method reads 'width' bytes from the buffer starting at the current offset and converts it to a BigInt.
     * The offset is advanced by 'width' bytes after successful deserialization.
     *
     * @param width - The number of bytes to read from the buffer to construct the BigInt (default is 32).
     * @returns The deserialized BigInt value.
     */
    bigInt(width = 32) {
        return this.exec((buf, offset) => deserializeBigInt(buf, offset, width));
    }
    /**
     * Deserialize a variable-length byte array from the internal buffer.
     * This method reads the length of the array and then extracts the corresponding bytes.
     * It advances the internal offset by the number of bytes read, including the length prefix.
     *
     * @returns A Buffer instance containing the deserialized byte array.
     */
    vector() {
        return this.exec(deserializeBufferFromVector);
    }
    /**
     * Extract a sub-buffer with the specified width, advancing the internal offset.
     * The function slices the buffer from the current offset to the offset plus the provided width,
     * and advances the internal offset by the width. This can be useful for working with fixed-width
     * structures within the original buffer.
     *
     * @param width - The number of bytes to include in the extracted sub-buffer.
     * @returns A sub-buffer containing the specified number of bytes from the original buffer.
     */
    buffer(width) {
        const buf = this.buf.slice(this.offset, this.offset + width);
        this.offset += width;
        return buf;
    }
    /**
     * Deserialize a string from the internal buffer.
     * It first deserializes a vector representing the UTF-8 encoded string from the buffer,
     * and then converts it to a string.
     *
     * @returns The deserialized string.
     */
    string() {
        return this.vector().toString();
    }
    /**
     * Deserialize a Date object from the internal buffer.
     * The date value is expected to be stored as a 64-bit BigInt representing the number of milliseconds since the Unix epoch.
     * Advances the internal offset by 8 bytes after deserialization.
     *
     * @returns A Date instance representing the deserialized date value.
     */
    date() {
        return new Date(Number(this.bigInt(8)));
    }
    /**
     * Deserialize an array of elements using the provided deserialization function.
     * This method reads the serialized data from the buffer and deserializes each element in the array
     * using the given 'fn' deserialization function. The returned array contains the deserialized elements
     * in their original order.
     *
     * @param fn - The deserialization function to be applied on each element in the array.
     * @returns An array containing the deserialized elements.
     */
    deserializeArray(fn) {
        return this.exec((buf, offset) => deserializeArrayFromVector(fn, buf, offset));
    }
    /**
     * Executes the given deserialization function on this Deserializer's buffer and updates the internal offset.
     * The DeserializeFn<T> should take a Buffer and an offset as input, and return an object containing the deserialized
     * element and the number of bytes advanced in the buffer. This method is useful for custom deserialization logic
     * or implementing new deserialization functions.
     *
     * @typeparam T - The type of the deserialized element.
     * @param fn - The deserialization function to execute.
     * @returns The deserialized element of type T.
     */
    exec(fn) {
        const { elem, adv } = fn(this.buf, this.offset);
        this.offset += adv;
        return elem;
    }
    /**
     * Returns the current offset value in the Deserializer instance.
     * The offset is updated as elements are deserialized from the buffer.
     * It can be useful for tracking the position in the buffer during complex deserialization processes.
     *
     * @returns The current offset value as a number.
     */
    getOffset() {
        return this.offset;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVzZXJpYWxpemVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcmlhbGl6ZS9kZXNlcmlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLDBCQUEwQixFQUMxQixpQkFBaUIsRUFDakIsZUFBZSxFQUNmLDJCQUEyQixFQUMzQixnQkFBZ0IsRUFDaEIsaUJBQWlCLEdBQ2xCLE1BQU0saUJBQWlCLENBQUM7QUFzQnpCOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsTUFBTSxPQUFPLFlBQVk7SUFDdkIsWUFBb0IsR0FBVyxFQUFVLFNBQVMsQ0FBQztRQUEvQixRQUFHLEdBQUgsR0FBRyxDQUFRO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBSTtJQUFHLENBQUM7SUFFdkQ7Ozs7OztPQU1HO0lBQ0ksSUFBSTtRQUNULE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU07UUFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSztRQUNWLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQVcsRUFBRSxNQUFjLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTTtRQUNYLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLE1BQU0sQ0FBQyxLQUFhO1FBQ3pCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQztRQUM3RCxJQUFJLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQztRQUNyQixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNO1FBQ1gsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLElBQUk7UUFDVCxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxnQkFBZ0IsQ0FBSSxFQUFvQjtRQUM3QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFXLEVBQUUsTUFBYyxFQUFFLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDakcsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLElBQUksQ0FBSSxFQUFvQjtRQUNqQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQztRQUNuQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7Q0FDRiJ9