/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '../serialize/buffer_reader.js';
import { Fr } from './fields.js';
/**
 * Represents a field element in a prime finite field with modulus defined by the constant MODULUS.
 * @remarks Called GrumpkinScalar because it is used to represent elements in Grumpkin's scalar field as defined in
 *          the Aztec Yellow Paper.
 */
export declare class GrumpkinScalar {
    /**
     * The element's value as a bigint in the finite field.
     */
    readonly value: bigint;
    static MODULUS: bigint;
    static MAX_VALUE: bigint;
    static SIZE_IN_BYTES: number;
    private static HIGH_SHIFT;
    private static LOW_MASK;
    constructor(
    /**
     * The element's value as a bigint in the finite field.
     */
    value: bigint);
    get low(): Fr;
    get high(): Fr;
    /**
     * Deserialize a grumpkin scalar serialized in 2 Fr.
     * @param high - The high Fr element.
     * @param low - The low Fr element.
     * @returns A GrumpkinScalar instance with the value of the two Fr elements.
     */
    static fromHighLow(high: Fr, low: Fr): GrumpkinScalar;
    /**
     * Generates a random GrumpkinScalar.
     *
     * @returns A new GrumpkinScalar instance with a randomly generated value.
     */
    static random(): GrumpkinScalar;
    /**
     * Create an instance of GrumpkinScalar from a given buffer or BufferReader.
     * @remarks Reads SIZE_IN_BYTES from the provided buffer and converts it to a bigint, then creates a new instance
     * with that value. Throws an error if the value is out of range for the calling class.
     *
     * @param buffer - The input buffer or BufferReader containing the bytes representing the value.
     * @returns A GrumpkinScalar instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): GrumpkinScalar;
    /**
     * Like fromBuffer, but reduces the value modulo MODULUS.
     *
     * @param buffer - The Buffer or BufferReader containing the bytes representing the value.
     * @returns GrumpkinScalar with the decoded value.
     */
    static fromBufferWithReduction(buffer: Buffer | BufferReader): GrumpkinScalar;
    /**
     * Create a GrumpkinScalar instance from a hex-encoded string.
     * The input 'address' can be either prefixed with '0x' or not, and should have exactly 64 hex characters.
     * Throws an error if the input length is invalid or the address value is out of range.
     *
     * @param address - The hex-encoded string representing the field element.
     * @returns A GrumpkinScalar instance.
     */
    static fromString(address: string): GrumpkinScalar;
    /**
     * Converts the bigint value of the instance to a Buffer representation.
     * The output buffer has a fixed size, determined by the 'SIZE_IN_BYTES' constant.
     *
     * @returns A Buffer containing the byte representation of the instance's value.
     */
    toBuffer(): Buffer;
    /**
     * Converts the GrumpkinScalar value to a hexadecimal string representation.
     * The resulting string is prefixed with '0x' and contains the exact number of hex characters required
     * to represent the numeric value of this instance.
     *
     * @param padTo32 - Whether to pad the resulting string to 32 bytes.
     * @returns A hexadecimal string representing the GrumpkinScalar value.
     */
    toString(padTo32?: boolean): `0x${string}`;
    /**
     * Check if the value of the current instance is zero.
     * This function compares the internal 'value' property with 0n (BigInt representation of zero).
     * Returns true if the value is zero, otherwise returns false.
     *
     * @returns A boolean indicating whether the value is zero or not.
     */
    isZero(): boolean;
    /**
     * Converts the value of the GrumpkinScalar instance to a friendly JSON format.
     * The output is a hexadecimal string representation of the value with '0x' prefix.
     *
     * @returns A string representing the value in the JSON format.
     */
    toFriendlyJSON(): `0x${string}`;
}
//# sourceMappingURL=grumpkin_scalar.d.ts.map