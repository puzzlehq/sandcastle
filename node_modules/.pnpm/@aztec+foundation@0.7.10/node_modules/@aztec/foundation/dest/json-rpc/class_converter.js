import { assert, hasOwnProperty } from './js_utils.js';
/**
 * Handles mapping of classes to names, and calling toString and fromString to convert to and from JSON-friendly formats.
 * Takes a class map as input.
 */
export class ClassConverter {
    /**
     * Create a class converter from a table of classes.
     * @param stringClassMap - The class table of string encoded classes.
     * @param objectClassMap - The class table of complex object classes
     */
    constructor(stringClassMap, objectClassMap) {
        this.toClass = new Map();
        this.toName = new Map();
        if (stringClassMap) {
            for (const key of Object.keys(stringClassMap)) {
                this.register(key, stringClassMap[key], 'string');
            }
        }
        if (objectClassMap) {
            for (const key of Object.keys(objectClassMap)) {
                this.register(key, objectClassMap[key], 'object');
            }
        }
    }
    /**
     * Register a class with a certain name.
     * This name is used for conversion from and to this class.
     * @param type - The class name to use for serialization.
     * @param class_ - The class object.
     * @param encoding - Whether the class is a complex object or simply represented by a string.
     */
    register(type, class_, encoding) {
        assert(type !== 'Buffer', "'Buffer' handling is hardcoded. Cannot use as name.");
        assert(hasOwnProperty(class_.prototype, 'toString') || hasOwnProperty(class_.prototype, 'toJSON'), `Class ${type} must define a toString() OR toJSON() method.`);
        assert(class_['fromString'] || class_['fromJSON'], `Class ${type} must define a fromString() OR fromJSON() static method.`);
        this.toName.set(class_, [type, encoding]);
        this.toClass.set(type, [class_, encoding]);
    }
    /**
     * Does this type name have a registered class?
     * @param type - The type name.
     * @returns If there's a registered class.
     */
    isRegisteredClassName(type) {
        return this.toClass.has(type);
    }
    /**
     * Is this class object registered?
     * @param obj - The class object.
     * @returns If it is a registered class.
     */
    isRegisteredClass(obj) {
        const name = obj.prototype.constructor.name;
        return this.toName.has(obj) || this.isRegisteredClassName(name);
    }
    /**
     * Convert a JSON-like object to a class object.
     * @param jsonObj - An object encoding a class.
     * @returns The class object.
     */
    toClassObj(jsonObj) {
        const result = this.toClass.get(jsonObj.type);
        assert(result, `Could not find type in lookup.`);
        const [class_, encoding] = result;
        if (encoding === 'string' && typeof jsonObj.data === 'string') {
            return class_.fromString(jsonObj.data);
        }
        else {
            return class_.fromJSON(jsonObj.data);
        }
    }
    /**
     * Convert a class object to a JSON object.
     * @param classObj - A JSON encoding a class.
     * @returns The class object.
     */
    toJsonObj(classObj) {
        const { type, encoding } = this.lookupObject(classObj);
        const data = encoding === 'string' ? classObj.toString() : classObj.toJSON();
        return { type: type, data };
    }
    /**
     * Loads the corresponding type for this class based on constructor first and constructor name if not found.
     * Constructor match works in the event of a minifier changing function names, and constructor name match
     * works in the event of duplicated instances of node modules being loaded (see #1826).
     * @param classObj - Object to lookup in the registered types.
     * @returns Registered type name and encoding.
     */
    lookupObject(classObj) {
        const nameResult = this.toName.get(classObj.constructor);
        if (nameResult)
            return { type: nameResult[0], encoding: nameResult[1] };
        const classResult = this.toClass.get(classObj.constructor.name);
        if (classResult)
            return { type: classObj.constructor.name, encoding: classResult[1] };
        throw new Error(`Could not find class ${classObj.constructor.name} in lookup.`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NfY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzb24tcnBjL2NsYXNzX2NvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQW1HdkQ7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLGNBQWM7SUFJekI7Ozs7T0FJRztJQUNILFlBQVksY0FBMEMsRUFBRSxjQUF3QztRQVJ4RixZQUFPLEdBQUcsSUFBSSxHQUFHLEVBQW9DLENBQUM7UUFDdEQsV0FBTSxHQUFHLElBQUksR0FBRyxFQUFvQyxDQUFDO1FBUTNELElBQUksY0FBYyxFQUFFO1lBQ2xCLEtBQUssTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtnQkFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ25EO1NBQ0Y7UUFDRCxJQUFJLGNBQWMsRUFBRTtZQUNsQixLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzthQUNuRDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFFBQVEsQ0FBQyxJQUFZLEVBQUUsTUFBZSxFQUFFLFFBQXVCO1FBQzdELE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLHFEQUFxRCxDQUFDLENBQUM7UUFDakYsTUFBTSxDQUNKLGNBQWMsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxFQUMxRixTQUFT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