{
    "name": "MultiTransfer",
    "functions": [
        {
            "name": "constructor",
            "functionType": "secret",
            "isInternal": false,
            "parameters": [],
            "returnTypes": [],
            "bytecode": "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",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        },
        {
            "name": "multiTransfer",
            "functionType": "secret",
            "isInternal": false,
            "parameters": [
                {
                    "name": "asset",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                },
                {
                    "name": "addresses",
                    "type": {
                        "kind": "array",
                        "length": 12,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "private"
                },
                {
                    "name": "amounts",
                    "type": {
                        "kind": "array",
                        "length": 12,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "private"
                },
                {
                    "name": "owner",
                    "type": {
                        "kind": "field"
                    },
                    "visibility": "private"
                },
                {
                    "name": "note_offsets",
                    "type": {
                        "kind": "array",
                        "length": 4,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "private"
                }
            ],
            "returnTypes": [],
            "bytecode": "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",
            "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
        }
    ],
    "debug": {
        "debugSymbols": [
            "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
            "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"
        ],
        "fileMap": {
            "1": {
                "source": "mod private_token_airdrop_interface;\n\n// Demonstrates how to perform 4 x 4 = 16 transfers in one transaction. Uses the private airdrop contract in the backend.\ncontract MultiTransfer {\n    // Interfaces\n    use crate::private_token_airdrop_interface::PrivateTokenAirdropPrivateContextInterface;\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    // Transfers 12 amounts to 12 recipients.\n    // multiTransfer() => 4 calls to batchTransfer() on the private airdrop contract.\n    // Each batchTransfer() call allows sending new notes to 3 recipients, so 3 x 4 = 12 recipients in total.\n    // Note that all the notes stay on the airdrop contract, the multi transfer contract must interact with \n    // methods in the private airdrop contract to initiate multiple transfers in one transaction. \n    #[aztec(private)]\n    fn multiTransfer(\n        asset: Field, // Asset to distribute\n        addresses: [Field; 12], // Addresses to distribute to\n        amounts: [Field; 12], // Amounts to distribute\n        owner: Field, // Owner of the asset\n        note_offsets: [Field; 4], // Offsets from which 4 notes of the owner would be read.\n    ) -> [Field; 4] {\n        let token = PrivateTokenAirdropPrivateContextInterface::at(asset);\n\n        // First batch transfer call\n        let result1 = token.batchTransfer(\n            &mut context,\n            owner, \n            [amounts[0], amounts[1], amounts[2]],\n            [addresses[0], addresses[1], addresses[2]],\n            note_offsets[0] as u32,\n        )[0];\n\n        // Second batch transfer call\n        let result2 = token.batchTransfer(\n            &mut context,\n            owner, \n            [amounts[3], amounts[4], amounts[5]],\n            [addresses[3], addresses[4], addresses[5]],\n            note_offsets[1] as u32,\n        )[0];\n\n        // Third batch transfer call\n        let result3 = token.batchTransfer(\n            &mut context,\n            owner, \n            [amounts[6], amounts[7], amounts[8]],\n            [addresses[6], addresses[7], addresses[8]],\n            note_offsets[2] as u32,\n        )[0];\n\n        // Fourth batch transfer call\n        let result4 = token.batchTransfer(\n            &mut context,\n            owner, \n            [amounts[9], amounts[10], amounts[11]],\n            [addresses[9], addresses[10], addresses[11]],\n            note_offsets[3] as u32,\n        )[0];\n\n        [result1, result2, result3, result4]\n    }\n}",
                "path": "/usr/src/yarn-project/noir-contracts/src/contracts/multi_transfer_contract/src/main"
            },
            "33": {
                "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
                "path": "/usr/src/yarn-project/aztec-nr/aztec/src/abi"
            },
            "38": {
                "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    // docs:start:context_message_portal\n    fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 48),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 64),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 80),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 96),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 100),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 104),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 106),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 108),\n                encrypted_log_preimages_length: fields[110],\n                unencrypted_log_preimages_length: fields[111],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[112],\n                    nullifier_tree_root : fields[113],\n                    contract_tree_root : fields[114],\n                    l1_to_l2_messages_tree_root : fields[115],\n                    blocks_tree_root : fields[116],\n                    public_data_tree_root: fields[117],\n                    global_variables_hash: fields[118],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[119], fields[120]),\n                    constructor_vk_hash : fields[121],\n                    function_tree_root : fields[122],\n                    contract_address_salt : fields[123],\n                    portal_contract_address : fields[124],\n                },\n                chain_id: fields[125],\n                version: fields[126],\n            },\n            is_execution_request: fields[127] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
                "path": "/usr/src/yarn-project/aztec-nr/aztec/src/context"
            },
            "54": {
                "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
                "path": "/usr/src/yarn-project/aztec-nr/aztec/src/oracle/arguments"
            },
            "55": {
                "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
                "path": "/usr/src/yarn-project/aztec-nr/aztec/src/oracle/call_private_function"
            },
            "69": {
                "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
                "path": "/usr/src/yarn-project/aztec-nr/aztec/src/private_call_stack_item"
            }
        }
    }
}
