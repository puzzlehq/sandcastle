import { CircuitsWasm, Fr } from '@aztec/circuits.js';
import { pedersenPlookupCommitInputs } from '@aztec/circuits.js/barretenberg';
import { toBigIntBE, toHex } from '@aztec/foundation/bigint-buffer';
import { keccak } from '@aztec/foundation/crypto';
import { createDebugLogger } from '@aztec/foundation/log';
import fs from 'fs';
/**
 * A class that provides utility functions for interacting with the chain.
 */
export class CheatCodes {
    constructor(
    /**
     * The cheat codes for ethereum (L1).
     */
    eth, 
    /**
     * The cheat codes for aztec.
     */
    aztec) {
        this.eth = eth;
        this.aztec = aztec;
    }
    static async create(rpcUrl, aztecRpc) {
        const ethCheatCodes = new EthCheatCodes(rpcUrl);
        const aztecCheatCodes = new AztecCheatCodes(aztecRpc, await CircuitsWasm.get(), ethCheatCodes);
        return new CheatCodes(ethCheatCodes, aztecCheatCodes);
    }
}
/**
 * A class that provides utility functions for interacting with ethereum (L1).
 */
export class EthCheatCodes {
    constructor(
    /**
     * The RPC client to use for interacting with the chain
     */
    rpcUrl, 
    /**
     * The logger to use for the eth cheatcodes
     */
    logger = createDebugLogger('aztec:cheat_codes:eth')) {
        this.rpcUrl = rpcUrl;
        this.logger = logger;
    }
    async rpcCall(method, params) {
        const paramsString = JSON.stringify(params);
        const content = {
            body: `{"jsonrpc":"2.0", "method": "${method}", "params": ${paramsString}, "id": 1}`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        };
        return await (await fetch(this.rpcUrl, content)).json();
    }
    /**
     * Get the current blocknumber
     * @returns The current block number
     */
    async blockNumber() {
        const res = await this.rpcCall('eth_blockNumber', []);
        return parseInt(res.result, 16);
    }
    /**
     * Get the current chainId
     * @returns The current chainId
     */
    async chainId() {
        const res = await this.rpcCall('eth_chainId', []);
        return parseInt(res.result, 16);
    }
    /**
     * Get the current timestamp
     * @returns The current timestamp
     */
    async timestamp() {
        const res = await this.rpcCall('eth_getBlockByNumber', ['latest', true]);
        return parseInt(res.result.timestamp, 16);
    }
    /**
     * Advance the chain by a number of blocks
     * @param numberOfBlocks - The number of blocks to mine
     * @returns The current chainId
     */
    async mine(numberOfBlocks = 1) {
        const res = await this.rpcCall('hardhat_mine', [numberOfBlocks]);
        if (res.error)
            throw new Error(`Error mining: ${res.error.message}`);
        this.logger(`Mined ${numberOfBlocks} blocks`);
    }
    /**
     * Set the next block timestamp
     * @param timestamp - The timestamp to set the next block to
     */
    async setNextBlockTimestamp(timestamp) {
        const res = await this.rpcCall('evm_setNextBlockTimestamp', [timestamp]);
        if (res.error)
            throw new Error(`Error setting next block timestamp: ${res.error.message}`);
        this.logger(`Set next block timestamp to ${timestamp}`);
    }
    /**
     * Dumps the current chain state to a file.
     * @param fileName - The file name to dump state into
     */
    async dumpChainState(fileName) {
        const res = await this.rpcCall('hardhat_dumpState', []);
        if (res.error)
            throw new Error(`Error dumping state: ${res.error.message}`);
        const jsonContent = JSON.stringify(res.result);
        fs.writeFileSync(`${fileName}.json`, jsonContent, 'utf8');
        this.logger(`Dumped state to ${fileName}`);
    }
    /**
     * Loads the chain state from a file.
     * @param fileName - The file name to load state from
     */
    async loadChainState(fileName) {
        const data = JSON.parse(fs.readFileSync(`${fileName}.json`, 'utf8'));
        const res = await this.rpcCall('hardhat_loadState', [data]);
        if (res.error)
            throw new Error(`Error loading state: ${res.error.message}`);
        this.logger(`Loaded state from ${fileName}`);
    }
    /**
     * Load the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @returns - The value at the storage slot
     */
    async load(contract, slot) {
        const res = await this.rpcCall('eth_getStorageAt', [contract.toString(), toHex(slot), 'latest']);
        return BigInt(res.result);
    }
    /**
     * Set the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @param value - The value to set the storage slot to
     */
    async store(contract, slot, value) {
        // for the rpc call, we need to change value to be a 32 byte hex string.
        const res = await this.rpcCall('hardhat_setStorageAt', [contract.toString(), toHex(slot), toHex(value, true)]);
        if (res.error)
            throw new Error(`Error setting storage for contract ${contract} at ${slot}: ${res.error.message}`);
        this.logger(`Set storage for contract ${contract} at ${slot} to ${value}`);
    }
    /**
     * Computes the slot value for a given map and key.
     * @param baseSlot - The base slot of the map (specified in Aztec.nr contract)
     * @param key - The key to lookup in the map
     * @returns The storage slot of the value in the map
     */
    keccak256(baseSlot, key) {
        // abi encode (removing the 0x) - concat key and baseSlot (both padded to 32 bytes)
        const abiEncoded = toHex(key, true).substring(2) + toHex(baseSlot, true).substring(2);
        return toBigIntBE(keccak(Buffer.from(abiEncoded, 'hex')));
    }
    /**
     * Send transactions impersonating an externally owned account or contract.
     * @param who - The address to impersonate
     */
    async startImpersonating(who) {
        const res = await this.rpcCall('hardhat_impersonateAccount', [who.toString()]);
        if (res.error)
            throw new Error(`Error impersonating ${who}: ${res.error.message}`);
        this.logger(`Impersonating ${who}`);
    }
    /**
     * Stop impersonating an account that you are currently impersonating.
     * @param who - The address to stop impersonating
     */
    async stopImpersonating(who) {
        const res = await this.rpcCall('hardhat_stopImpersonatingAccount', [who.toString()]);
        if (res.error)
            throw new Error(`Error when stopping the impersonation of ${who}: ${res.error.message}`);
        this.logger(`Stopped impersonating ${who}`);
    }
    /**
     * Set the bytecode for a contract
     * @param contract - The contract address
     * @param bytecode - The bytecode to set
     */
    async etch(contract, bytecode) {
        const res = await this.rpcCall('hardhat_setCode', [contract.toString(), bytecode]);
        if (res.error)
            throw new Error(`Error setting bytecode for ${contract}: ${res.error.message}`);
        this.logger(`Set bytecode for ${contract} to ${bytecode}`);
    }
    /**
     * Get the bytecode for a contract
     * @param contract - The contract address
     * @returns The bytecode for the contract
     */
    async getBytecode(contract) {
        const res = await this.rpcCall('eth_getCode', [contract.toString(), 'latest']);
        return res.result;
    }
}
/**
 * A class that provides utility functions for interacting with the aztec chain.
 */
export class AztecCheatCodes {
    constructor(
    /**
     * The RPC client to use for interacting with the chain
     */
    aztecRpc, 
    /**
     * The circuits wasm module used for pedersen hashing
     */
    wasm, 
    /**
     * The eth cheat codes.
     */
    eth, 
    /**
     * The logger to use for the aztec cheatcodes
     */
    logger = createDebugLogger('aztec:cheat_codes:aztec')) {
        this.aztecRpc = aztecRpc;
        this.wasm = wasm;
        this.eth = eth;
        this.logger = logger;
    }
    /**
     * Computes the slot value for a given map and key.
     * @param baseSlot - The base slot of the map (specified in Aztec.nr contract)
     * @param key - The key to lookup in the map
     * @returns The storage slot of the value in the map
     */
    computeSlotInMap(baseSlot, key) {
        // Based on `at` function in
        // aztec3-packages/yarn-project/aztec-nr/aztec/src/state_vars/map.nr
        return Fr.fromBuffer(pedersenPlookupCommitInputs(this.wasm, [new Fr(baseSlot), new Fr(key)].map(f => f.toBuffer())));
    }
    /**
     * Get the current blocknumber
     * @returns The current block number
     */
    async blockNumber() {
        return await this.aztecRpc.getBlockNumber();
    }
    /**
     * Set time of the next execution on aztec.
     * It also modifies time on eth for next execution and stores this time as the last rollup block on the rollup contract.
     * @param to - The timestamp to set the next block to (must be greater than current time)
     */
    async warp(to) {
        const rollupContract = (await this.aztecRpc.getNodeInfo()).rollupAddress;
        await this.eth.setNextBlockTimestamp(to);
        // also store this time on the rollup contract (slot 1 tracks `lastBlockTs`).
        // This is because when the sequencer executes public functions, it uses the timestamp stored in the rollup contract.
        await this.eth.store(rollupContract, 1n, BigInt(to));
        // also store this on slot 2 of the rollup contract (`lastWarpedBlockTs`) which tracks the last time warp was used.
        await this.eth.store(rollupContract, 2n, BigInt(to));
    }
    /**
     * Loads the value stored at the given slot in the public storage of the given contract.
     * @param who - The address of the contract
     * @param slot - The storage slot to lookup
     * @returns The value stored at the given slot
     */
    async loadPublic(who, slot) {
        const storageValue = await this.aztecRpc.getPublicStorageAt(who, new Fr(slot));
        if (storageValue === undefined) {
            throw new Error(`Storage slot ${slot} not found`);
        }
        return Fr.fromBuffer(storageValue);
    }
    /**
     * Loads the value stored at the given slot in the private storage of the given contract.
     * @param contract - The address of the contract
     * @param owner - The owner for whom the notes are encrypted
     * @param slot - The storage slot to lookup
     * @returns The notes stored at the given slot
     */
    loadPrivate(owner, contract, slot) {
        return this.aztecRpc.getPrivateStorageAt(owner, contract, new Fr(slot));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlYXRfY29kZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvY2hlYXRfY29kZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFnQixZQUFZLEVBQWMsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDaEYsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDOUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHMUQsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBRXBCOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFVBQVU7SUFDckI7SUFDRTs7T0FFRztJQUNJLEdBQWtCO0lBQ3pCOztPQUVHO0lBQ0ksS0FBc0I7UUFKdEIsUUFBRyxHQUFILEdBQUcsQ0FBZTtRQUlsQixVQUFLLEdBQUwsS0FBSyxDQUFpQjtJQUM1QixDQUFDO0lBRUosTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBYyxFQUFFLFFBQWtCO1FBQ3BELE1BQU0sYUFBYSxHQUFHLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hELE1BQU0sZUFBZSxHQUFHLElBQUksZUFBZSxDQUFDLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQyxHQUFHLEVBQUUsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUMvRixPQUFPLElBQUksVUFBVSxDQUFDLGFBQWEsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUN4RCxDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxhQUFhO0lBQ3hCO0lBQ0U7O09BRUc7SUFDSSxNQUFjO0lBQ3JCOztPQUVHO0lBQ0ksU0FBUyxpQkFBaUIsQ0FBQyx1QkFBdUIsQ0FB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